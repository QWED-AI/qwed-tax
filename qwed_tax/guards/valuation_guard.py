from decimal import Decimal, InvalidOperation
from typing import Dict, Any

class ValuationGuard:
    """
    Deterministic Guard for Startup Conversions (Convertible Notes/SAFEs).
    Verifies Pre-Money vs Post-Money share price math.
    """

    def verify_conversion(self, investment: str, cap: str, discount: str, next_round_price: str) -> Dict[str, Any]:
        """
        Verifies share conversion price for startups.
        Math: Price = min(Cap_Price, Next_Round_Price * (1 - Discount))
        """
        try:
            d_cap = Decimal(cap)
            d_next = Decimal(next_round_price)
            d_disc = Decimal(discount)
            d_inv = Decimal(investment)
        except InvalidOperation:
             return {"verified": False, "error": "Invalid numerical input for valuation."}
        
        # Calculate Price based on Discount
        discounted_price = d_next * (1 - d_disc)
        
        # Calculate Price based on Cap
        # Note: If Fully Diluted Shares (FDS) isn't provided, we assume 'cap' is the Price Cap?
        # Usually Cap / FDS = Cap Price.
        # The prompt implies 'cap' passed might be the 'Cap Valuation' OR 'Cap Price'.
        # Prompt logic: `min(Cap, discounted)`. 
        # If 'Cap' is meant to be the *Price generated by Cap*, then logic holds.
        # If 'Cap' is Valuation, we need FDS.
        # For this implementation, we assume the input 'cap' represents the *Effective Price Limit* (Cap / FDS).
        
        final_price = min(d_cap, discounted_price)
        method = "CAP" if final_price == d_cap else "DISCOUNT"
        
        shares = d_inv / final_price
        
        return {
            "verified": True,
            "deterministic_price": str(final_price),
            "shares_issued": str(shares),
            "method": method
        }
